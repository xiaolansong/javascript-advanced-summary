第四章 表达式和运算符
表达式是JavaScript中的一个短语，JavaScript解释器会将其计算出一个结果。

4.1 原始表达式
最简单的表达式是"原始表达式"。原始表达式是表达式的最小单位——它们不再包含其他表达式。
JavaScript中的原始表达式包含常量或直接量，关键字和变量。
直接量是直接在程序中出现的常数值。例如：1.23  "hello"
JavaScript中的一些保留字构成了原始表达式：true  false null  this
第三种原始表达式是变量：i  sum  undefined
当JavaScript代码中出现了标识符，JavaScript会 将其当做变量而去查找它的值。如果变量名不存在，表达式运算结果为undefined。
然而，在ECMAScript 5的严格模式中，对不存在的变量进行求值会抛出一-个引用错误异常。

4.2 对象和数组的初始表达式
对象和数组初始化表达式实际上是一个新创建的对象和数组。这些初始化表达式有时称做“对象直接量”和“数组直接量”。
然而和布尔直接量不同，它们不是原始表达式，因为它们所包含的成员或者元素都是子表达式。

数组初始化表达式是通过一对方括号和其内由逗号隔开的列表构成的。
初始化的结果是一个新创建的数组。数组的元素是逗号分隔的表达式的值。
数组初始化表达式中的元素初始化表达式也可以是数组初始化表达式。
也就是说，这些表达式是可以嵌套的。var matrix=[[1,2,3],[4,5,6],[7,8,9]]
JavaScript对数组初始化表达式进行求值的时候，数组初始化表达式中的元素表达式也
都会各自计算一次。也就是说，数组初始化表达式每次计算的值有可能是不同的。
数组直接量中的列表逗号之间的元素可以省略，这时省略的空位会填充值undefined。
例如，下面这个数组包含5个元素，其中三个元素是undefined:
var sparseArray=[1,,,,5]

对象初始化表达式和数组初始化表达式非常相似，只是方括号被花括号代替，并且每个子表达式都包含一个属性名和一个冒号作为前缀
对象直接量也可以嵌套。
JavaScript求对象初始化表达式的值的时候，对象表达式也都会各自计算一次，并且它们不必包含常数值:它们可以是任意JavaScript表达式。
同样，对象直接量中的属性名称可以是字符串而不是标识符。

4.3 函数定义表达式
函数定义表达式定义一个JavaScript函数。表达式的值是这个新定义的函数。
一个典型的函数定义表达式包含关键字function，例如var square=function(x){return x*x;}
函数定义表达式同样可以包含函数的名字。

4.4 属性访问表达式
属性访问表达式运算得到一个对象属性或一个数组元素的值。
expression.identifier
expression[expression]
第一种写法是一个表达式后跟随一个句点和标识符。表达式指定对象，标识符则指定需要访问的属性的名称。
第二种写法是使用方括号，方括号内是另外一个表达式(这种方法适用于对象和数组)。第二个表达式指定要访问的属性的名称或者代表要访问数组元素的索引。
显然 .identifier的写法更加简单，但需要注意的是，这种方式只适用于要访问的属性名称是合法的标识符，并且而需要知道要访问的属性的名字。
如果属性名是一个保留字或者包含空格和标点符号，或是一个数字（对于数组来说），则必须使用方括号的写法。
当属性名是通过计算得出的值而不是固定的值的时候，这是必须使用方括号写法。

4.5 调用表达式
JavaScript中的调用表达式是一种调用（或者执行）函数或方法的语法表示。
它以一个函数表达式开始，这个函数表达式指代了要调用的函数。函数表达式后跟随一对圆括号，括号内是一个以逗号隔开的参数列表。
任何一个调用表达式都包含一对圆括号和左圆括号之前的表达式。如果这个表达式是一个属性访问表达式，那么这个调用称做“方法调用”。 
在方法调用中，执行函数体的时候，作为属性访问主题的对象和数组便是其调用方法内thi s的指向。


4.6 对象创建表达式
对象创建表达式创建一个对象并调用一个函数初始化新对象的属性。
对象创建表达式和函数调用表达式非常相似，只是对象创建表达式之前多了一个关键字new

4.7 运算符概述
JavaScript中的运算符用于算术表达式、比较表达式、逻辑表达式、赋值表达式等。
大多数运算符都是由标点符号表示的。例如“+”和“=”；有一些运算符是由关键字表示的，比如delete和instanceof

4.7.1 操作数的个数
运算符可以根据其操作数的个数进行分类。JavaScript中的大 多数运算符(比如“*”乘法运算符)是一个二元运算符(binary operator)，将两个表达式合并成-一个稍复杂的表达式。
换言之，它们的操作数均是两个。
JavaScript同样支持一些一元运算符(unaryoperator)，它们将-一个表达式转换为另一个稍复杂的表达式。表达式-x中的“-”运.算符就是一一个一元运算符，是将操作数x求负值。
最后，JavaScript支持-一个三元运算符(termary operator)，条件判断运算符“?:” ，它将三个表达式合并成-一个表达式。

4.7.2 操作数类型和结果类型
JavaScript运算符通常会根据需要对操作数进行类型转换(参照3.8节)。乘法运算符
“*”
希望操作数为数字，但表达式"3**"5"却是合法的，因为JavaScript会 将操作数转换为数字。
这个表达式的值是数字15，而不是字符串“15” 。
JavaScript中的所有值不是真值就是假值，因此对于那些希望操作数是布尔类型的操作符来说，它们的操作数可以是任意类型。
有一些运算符对操作数类型有着不同程度的依赖。最明显的例子是加法运算符，“+”运算符可以对数字进行加法运算，也可以对字符串作连接。
同样，比如“<”比较运算符可以根据操作数类型的不同对数字进行大小值的比较，也可以比较字符在字母表中的次序先后。
单个运算符的描述充分解释了它们对类型有着怎样的依赖以及对操作数进行怎样的类型转换。

4.7.3 左值
左值是指表达式只能出现在赋值运算符的左侧
在JavaScript中对象属性和数组元素均是左值。ECMAScript规范允许内置函数返回一个左值，但自定义的函数不能返回左值

4.7.4 运算符的副作用
有一些表达式具有很多副作用，前后的表达式运算会互相影响。
赋值运算符是最明显的例子：如果给一个变量或属性赋值，那么那些使用这个变量或属性的表达式的值都会发生改变。
“++”和“--”递增和递减运算符与此类似，因为它们包含隐式的赋值。
delete运算符同样有副作用:删除一个属性就像(但不完全-样)给这个属性赋值undefined。

4.8.1 “+”运算符
二元加法运算符“+”可以对两个数字做加法，也可以做字符串连接操作。
当两个操作数都是数字或都是字符串的时候，结果显而易见。对于其他情况：
从技术上讲，加法操作符的行为表现为：
如果其中一个操作数是对象，则对象会遵循对象到原始值的转换规则转换为原始
类值，日期对象通过toString()方法执行转换，其他对象则通过value0f()方法执行
转换(如果value0f()方法返回一个原始值的话)。由于多数对象都不具备可用的
va1ue0f()方法，因此它们会通过toString()方法来执行转换。
在进行了对象到原始值的转换后，如果其中一个操作数是字符串的话，另一个操作
数也会转换为字符串，然后进行字符串连接。
否则，两个操作数都将转换为数字(或者NaN) ，然后进行加法操作。

4.8.2 一元算术运算符
一元运算符作用于一个单独的操作数，并产生一个新值。
在JavaScript中，一元运算符具有很高的优先级，而且都是又结合。
一元加法（+）
一元加法运算符把操作数转换为数字(或者NaN), 并返回这个转换后的数字。
如果操作数本身就是数字，则直接返回这个数字。
一元减法（-）
当“-”用做一元运算符时，它会根据需要把操作数转换为数字，然后改变运算结果的符号。
递增（++）
递增“++” 运算符对其操作数进行增量(加一)操作，操作数是一个左值(1value) (变量、 数组元素或对象属性)。
运算符将操作数转换为数字，然后给数字加1，并将加1后的数值重新赋值给变量、数组元素或者对象属性。
递增“++”运算符的返回值依赖于它相对于操作数的位置。
当运算符在操作数之前，称为“前增量”(pre-increment) 运算符，它对操作数进行增量计算，并返回计算后的值。
当运算符在操作数之后，称为“后增量”(post-increment) 运算符，它对操作数进行增量计算，但返回未做增量计算的(unincremented) 值。
递减（--）
递减“--”运算符的操作数也是一个左值。它把操作数转换为数字，然后减1,并将计算后的值重新赋值给操作数。
和“++” 运算符-样，递减“--”运算符的返回值依赖于它相对操作数的位置，
当递减运算符在操作数之前，操作数减1并返回减1之后的值。
当递减运算符在操作数之后，操作数减1并返回减1之前的值。
当递减运算符在操作符的右侧时，运算符和操作数之间不能有换行符。

4.9 关系表达式
关系运算符用于测试两个值之间的关系，根据关系是否存在而返回true或false

4.9.1 相等和不等运算符
“==”和“===”运算符用于比较两个值是否相等，当然它们对相等的定义不尽相同。
两个运算符允许任意类型的操作数，如果操作数相等则返回true,否则返回false。
“===”也称为严格相等运算符(strict equality) (有时也称做恒等运算符(identity
operator))，它用来检测两个操作数是否严格相等。
‘==”运算符称做相等运算符(equality operator)，它用来检测两个操作数是否相等，
这里“相等”的定义非常宽松，可以允许进行类型转换。

“!=”和“!==”运算符的检测规则是“=="和“===”运算符的求反。如果两个值通
过“==”的比较结果为true，那么通过“!=” 的比较结果则为false。如果两值通过
“===”的比较结果为true,那么通过“!==” 的比较结果则为false。4.10节会提到，
“!”运算符是布尔非运算符。我们只要记住“!=” 称做“不相等”、“!==”称做“不
严格相等”就可以了。

JavaScript对象的比较是引用的比较，而不是值的比较。对象和其本身是相等的，但和其他任何对象都不相等
相应位置的数组元素是相等的两个数组也是不相等的

严格相等运算符“===”首先计算其操作数的值，然后比较这两个值，比较过程没有任何类型转换:

如果两个值类型不相同，则它们不相等。
如果两个值都是null或者都是undefined，则它们不相等。
如果两个值都是布尔值true或都是布尔值false,则它们相等。
如果其中-一个值是NaN,或者两个值都是NaN,则它们不相等。Na N和其他任何值都
是不相等的，包括它本身!通过x!==x来判断x是否为NaN，只有在x为NaN的时候，这
个表达式的值才为true。
如果两个值为数字且数值相等，则它们相等。如果-一个值为0，另-一个值为-0,则
它们同样相等。
如果两个值为字符串，且所含的对应位上的16位数(参照3.2节)完全相等，则它
们相等。如果它们的长度或内容不同，则它们不等。两个字符串可能含义完全一样
且所显示出的字符也- -样，但具有不同编码的16位值。JavaScript拼不对Unicode进
行标准化的转换，因此像这样的字符串通过“===" 和“==”运算符的比较结果也
不相等。第三部分的String. localeCompare()提供了另外- -种比较字符串的方法。
如果两个引用值指向同一个对象、数组或函数，则它们是相等的。如果指向不同的
对象，则它们是不等的，尽管两个对象具有完全-样的属性。

相等运算符‘'== '和恒等运算符相似，但相等运算符的比较并不严格。如果两个操作数
不是同一类型，那么相等运算符会尝试进行- -些类型转换，然后进行比较:
如果两个操作数的类型相同，则和上文所述的严格相等的比较规则一样。如果严格
相等，那么比较结果为相等。如果它们不严格相等，则比较结果为不相等。
如果两个操作数类型不同，“== ”相等操作符也可能会认为它们相等。检测相等
将会遵守如下规则和类型转换:
如果一个值是null， 另一个是undefined， 则它们相等。
如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换
后的值进行比较。
如果其中一个值是true,则将其转换为1再进行比较。如果其中-一个值是false,
则将其转换为0再进行比较。
如果一个值是对象，另一个值是数字或字符串，则使用3.8.3节所提到的转
换规则将对象转换为原始值，然后再进行比较。对象通过toString()方法或
者value0f()方法转换为原始值。JavaScript语言核心的内置类首先尝试使用
value0f()， 再尝试使用toString()，除了日期类，日期类只使用toString()转
换。那些不是JavaScript语言核心中的对象则通过各自的实现中定义的方法转换.
为原始值。
其他不同类型之间的比较均不相等。

4.9.2 比较运算符
比较运算符用来检测两个操作数的大小关系（数值大小或者字母表的排序）
<  >  <=  >=
比较操作符的操作数可能是任意类型。然而，只有数字和字符串才能真正执行比较操
作，因此那些不是数字和字符串的操作数都将进行类型转换，类型转换规则如下:
①如果操作数为对象，那么这个对象将依照转换规则转换为原始值，如果valueOf()返回一个原始值，那么直接使用使用这个原始值。
否则，使用toString()的转换结果进行比较操作。
②在对象转换为原始值之后，如果两个操作数都是字符串，那么将依照字母表的顺序
对两个字符串进行比较，这里提到的“字母表顺序”是指组成这个字符串的16位Unicode字符的索引顺序。
③在对象转换为原始值之后，如果至少有一个操作数不是字符串，那么两个操作数都
将转换为数字进行数值比较。0和-0是相等的。Infinity比其他任何数字都大(除了Infinity本身)，
-Infinity比其他任何数字都小(除了它自身)。如果其中一个操作数是(或转换后是) NaN, 那么比较操作符总是返回false.

需要注意的是，JavaScript字符串是一个由16位整数值组成的序列，字符串的比较也只是
两个字符串中的字符的数值比较。
注意，字符串比较是区分大小写的，所有的大写的ASCII字母都“小于”小写的ASCII字母。如果不注意这条不起眼的规则的
话会造成-些小麻烦。比如，使用“<” 小于运算符比较“Zoo” 和“aardvark" ，结果为true。

对于数字和字符串操作符来说，加号运算符和比较运算符的行为都有所不同，前者更偏
爱字符串，如果它的其中一个操作数是字符串的话，则进行字符串连接操作。而比较运
算符则更偏爱数字，只有在两个操作数都是字符串的时候，才会进行字符串的比较。
11<3//false
"11"<"3"//true
最后，需要注意的是，“<=” (小于等于) 和“>=”(大于等于) 运算符在判断相等的
时候，并不依赖于相等运算符和严格相等运算符的比较规则。相反，小于等于运算符只
是简单的“不大于”，大于等于运算符也只是“不小于”。只有-一个例外，那就是当其
-一个操作数是(或者转换后是) NaN的时候，所有4个比较运算符均返回false。

4.10 逻辑表达式
逻辑运算符"&&"、"||"和"!"是对操作数进行布尔算术运算，经常和关系运算符
一起配合使用，逻辑运算符将多个关系表达式组合起来组成-一个更复杂的表达式。

4.10.1 逻辑与&&
“&&”运算符可以从三个不同的层次进行理解。
①最简单的第一层理解是，当操作数都是布尔值的时候，“&&” 对两个值执行布尔与(AND)操作，只有在第一个操作数和第二个
操作数都是true的时候，它才返回true。如果其中-一个操作数是false，它返回false。
②对“&&” 的第二层理解是，“ &&”可以对真值和假值进行布尔与(AND) 操作。
如果两个操作数都是真值，那么返回一个真值;否则，至少一个操作数是假值的话，则返回一个假值。
在JavaScript中 任何希望使用布尔值的地方，表达式和语句都会将其当做真值或假值来对待，因此实际上“&&” 并不总是返回true和false,但
③运算符首先计算左操作数的值，即首先计算“&&” 左侧的表达式。
如果计算结果是假值，那么整个表达式的结果一定也是假值，因此“&&” 这时简单地返回左操作数的值，而并不会对右操作数进行计算。
反过来讲，如果左操作数是真值，那么整个表达式的结果则依赖于右操作数的值。如果右操作数是真值，那么整个表达式的值一定是真值; 
如果右操作数是假值，那么整个表达式的值一定是假值。因此，当左操作数是真值时，“&&”运算符将计算右操作数的值并将其返回作为整个表达式的计算结果:

4.10.2 逻辑或（||）
“||”运算符对两个操作数做布尔或(OR)运算。如果其中一个或者两个操作数是真值，它返回一个真值。如果两个操作数都是假值，它返回一个假值。
尽管“|I”运算符大多数情况下只是做简单布尔或(OR) 运算，和“&&”一样，它也具
有一些更复杂的行为。它会首先计算第一个操作数的值，也就是说会首先计算左侧的表
达式。如果计算结果为真值，那么返回这个真值。否则，再计算第二个操作数的值，即
计算右侧的表达式，并返回这个表达式的计算结果。

4.10.3 逻辑非（!）
“!”运算符是-元运算符。它放置在一个单独的操作数之前。它的目的是将操作数的布
尔值进行求反。例如，如果x是真值，则!x返回false;如果x是假值，则!x返回true.和“&&”
与“||”运算符不同，“!”运算符首先将其操作数转换为布尔值，然后再对布尔值求反。
也就是说“!”总是返回true或者false,并且，可以通过使用两次逻辑非运算来得到一个值的等价布尔值: !!x (参照3.8.2节)。
作为-一个一元运算符”!”具有很高的优先级，并且和操作数紧密绑定在一起。
如果你希望对类似p && q的表达式做求反操作，则需要使用圆括号: !(p && q)。

4.11 赋值表达式
JavaScript使用"="运算符来给变量或属性赋值
具有非常低的优先级，通常在一个较长的表达式中用到了一条赋值语句的值的时
候，需要补充圆括号以保证正确的运算顺序。
赋值操作符的结合性是从右至左，也就是说，如果一个表达式中出现了多个赋值运算
符，运算顺序是从右到左。因此，可以通过如下的方式来对多个变量赋值:
i=j=k=0//把三个变量初始化为0

4.13.2 typeof运算符
typeof是一元运算符， 放在其单个操作数的前面，操作数可以是任意类型。返回值为表
示操作数类型的-一个字符串。
undefined//"undefined"
null//"object"
任意函数//“function”

4.13.5 逗号运算符
逗号运算符是二元运算符，它的操作数可以是任意类型。它首先计算左操作数，然后计
算右操作数，最后返回右操作数的值。




第5章 语句
JavaScript程序无非就是-系列可执行语句的集合。默认情况下，JavaScript解释器依
照语句的编写顺序依次执行。另一种“使某件事发生”的方法是改变语句的默认执行
顺序。JavaScript中有很多语句和控制结构(control structure)来改变语句的默认执行
顺序:
①条件(conditional) 语句，JavaScript解释器可以根据-一个表达式的值来判断是执行
还是跳过这些语句，如if语句和switch语句。
②循环(loop) 语句，可以重复执行语句，如while和for语句。
③跳转(jump) 语句，可以让解释器跳转至程序的其他部分继续执行，如break、
return和throw语句。

5.1 表达式语句
表达式时JavaScript中最简单的语句。
赋值语句是一类比较重要的表达式语句。
递增运算符(++) 和递减运算符(--) 和赋值语句有关。它们的作用是改变-一个变量的
值，就像执行一条赋值语句一样。
delete运算符的重要作用是删除-一个对象的属性，所以，它一般作为语句使用，而不是
作为复杂表达式的一部分。
函数调用时表达式语句的另一个大类。例如：
alert(greeting);
window.close();

5.2 复合语句和空语句
关于语句块有几点需要注意，第一，语句块的结尾不需要分号。块中的原始语句必须以
分号结束，但语句块不需要。第二，语句块中的行都有缩进，这不是必需的，但整齐的
缩进能让代码可读性更强，更容易理解。最后，需要注意，JavaScript中没 有块级作用
域，在语句块中声明的变量并不是语句块私有的。
JavaScript解释器执行空语句时它显然不会执行任何动作。但实践证明，当创建一一个具有空
循环体的循环时，空语句有时是很有用的。例如下面的for循环 :
//初始化-一个数组a
for(i = 0; i < a.1ength; a[i++] = 0) ;
在这个循环中，所有的操作都在表达式a[i++ ]=0中完成，这里并不需要任何循环体。然
而JavaScript需要循环体中至少包含一条语句，因此，这里只使用了一个单独的分号来表
示一条空语句。

5.3 声明语句
var和function都是声明语句，它们声明或定义变量或函数。这些语句定义标识符(变量
名和函数名)并给其赋值，这些标识符可以在程序中任意地方使用。

5.3.1 var
var用来声明一个或多个变量
如果v ar语句出现在函数体内，那么它定义的是一个局部变量，其作用域就是这个函数。
如果在顶层代码中使用var语句，它声明的是全局变量，在整个JavaScript程序中都是可
见的。全局变量是全局对象的属性。然而和其他全局对象属性不同的是，var声明的变量
是无法通过delete删除的。
如果v ar语句中的变量没有指定初始化表达式，那么这个变量的值初始为undefined.
，变量在声明它们的脚本或函数中都是有定义的，变量声明语句会被“提前”至脚本
或者函数的顶部。但是初始化的操作则还在原来var语句的位置执行，在声明语句之前
变量的值是undefined.
需要注意的是，var语句同样可以作为for循环或for/in循环的组成部分。

5.3.2 function
关键字function用来定义函数，函数定义也可以写成语句的形式：
①var f=function(x){return x+1;}
②function f(x){return x+1;}
函数声明：
function hypotenuse(x,y){
	return Math.sqrt(x*x+y*y);
}
函数声明语句通常出现在JavaScript代码的最顶层，也可以嵌套在其他函数体内。但在
嵌套时，函数声明只能出现在所嵌套函数的顶部。也就是说，函数定义不能出现在if语
句、while循环或其他任何语句中，正是由于函数声明位置的这种限制，ECMAScript标
准规范并没有将函数声明归类为真正的语句。有- -些JavaScript实现的确允许在出现语句
的地方都可以进行函数声明，但是不同的实现在细节处理方式上有很大差别，因此将函
数声明放在其他的语句内的做法并不具备可移植性。
尽管函数声明语句和函数定义表达式包含相同的函数名，但二者仍然不同。两种方式都
创建了新的函数对象，但函数声明语句中的函数名是一个变量名，变量指向函数对象。
和通过var声明变量--样，函数定义语句中的函数被显式地“提前”到了脚本或函数的
顶部。因此它们在整个脚本和函数内都是可见的。使用var的话，只有变量声明提前
了一变量的初始化代码仍然在原来的位置。然而使用函数声明语句的话，函数名称和
函数体均提前:脚本中的所有函数和函数中所有嵌套的函数都会在当前上下文中其他代
码之前声明。也就是说，可以在声明-一个JavaScript函数之前调用它。
和var语句一样，函数声明语句创建的变量也是无法删除的。但是这些变量不是只读
的，变量值可以重写。

5.4 条件语句
条件语句是通过判断指定表达式的值来决定执行还是跳过某些语句。
if     else if     switch

5.5 循环
循环语句就是程序路径的一个回路，可以让一部分代码重复执行。
JavaScript中有4种循环语句：
while     do/while     for     for/in

5.5.4 for/in
for/in语句也使用for关键字，但它是和常规的f or循环完全不同的- -类循环。for/in循
环语句的语法如下:
for (variable in object)
statement
variable通常是-一个变量名，也可以是一个可以产生左值的表达式或者一个通过var语句
声明的变量，总之必须是一个适用于赋值表达式左侧的值。object是- 一个表达式，这个
表达式的计算结果是-一个对象。 同样，statement是- 一个语句或语句块，它构成了循环的
主体。
使用for循环来遍历数组元素是非常简单的:
for(var i = 0; i < a.1ength; it+)
//i代表了数组元素的索引
console.1og(a[i]);
//输出数组中的每个元素
而for/ in循环则是用来更方便地遍历对象属性成员:
for(var p in o)
//将属性名字赋值给变量p
console.1og(o[p]);
//输出每一个属性的值
在执行for/in语句的过程中, JavaScript解释器首先计算object表达式。如果表达式为
nu11或者undefined, JavaScirpt解释 器将会跳过循环并执行后续的代码生3。如果表达式
等于一个原始值，这个原始值将会转换为与之对应的包装对象(wrapper object) (见3.6
节)。否则，expression本身已经是对象了。JavaScript会依次枚举对象的属性来执行循
环。然而在每次循环之前，JavaScript都会先计算variab1e表达式的值，并将属性名(一
个字符串)赋值给它。
需要注意的是，只要for/in循环中variable的值 可以当做赋值表达式的左值，它可以是
任意表达式。每次循环都会计算这个表达式，也就是说每次循环它计算的值有可能不
同。

5.6 跳转
JavaScript中另一类语句是跳转语句(jump statement)。从名称就可以看出，它使得
JavaScript的执行可以从一个位置跳转到另一个位置。break语句是跳转到循环或者其他
语句的结束。continue语 句是终止本次循环的执行并开始下一次循环的执行。JavaScript
中的语句可以命名或带有标签，break和continue可以标识目标循环或者其他语句标签。
return语句让解释器跳出函数体的执行，并提供本次调用的返回值。

5.6.1 标签语句
语句是可以添加标签的，标签是由语句前的标识符和冒号组成
identifier:statement



































