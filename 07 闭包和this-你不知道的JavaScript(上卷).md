词法作用域

2.1 词法阶段
简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写
代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域
不变(大部分情况下是这样的)。.
function foo(a) {
	varb=a*2;
	function bar(c) {
		console.log( a, b, c);
	}
	bar(b*3);
}
foo(2);//2,4,12
在这个例子中有三个逐级嵌套的作用域。
①包含着整个全局作用域，其中只有一个标识符: foo。
②包含着foo所创建的作用域，其中有三个标识符: a、 bar 和b。
③包含着bar所创建的作用域，其中只有一一个标识符: C。

函数作用域和块作用域

3.1 函数中的作用域
JavaScript具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡，
而其他结构都不会创建作用域气泡。但事实上这并不完全正确。
首先需要研究一下函数作用域及其背后的一些内容。
考虑下面的代码:
	function foo(a) {
		var b=2;
		//一些代码
		function bar() {
		// ...
		}
		//更多的代码
		var c=3;
	}
在这个代码片段中，foo(..) 的作用域气泡中包含了标识符a、b、c和bar。无论标识符
声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气
泡。我们将在下一章讨论具体的原理。
bar(..)拥有自己的作用域气泡。全局作用域也有自己的作用域气泡，它只包含了一个标
识符: foo。
由于标识符a、b、c和bar都附属于foo(..)的作用域气泡，因此无法从foo(..)的外部
对它们进行访问。也就是说，这些标识符全都无法从全局作用域中进行访问，因此下面的
代码会导致ReferenceError错误:
	bar(); //失败
	console.log( a, b, c ); //三个全都失败
但是，这些标识符(a.b、C、foo和bar)在foo(..)的内部都是可以被访问的，同样在
bar(..)内部也可以被访问(假 设bar(..)内部没有同名的标识符声明)。
函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复
用(事实上在嵌套的作用域中也可以使用)。这种设计方案是非常有用的，能充分利用
JavaScript变量可以根据需要改变值类型的“ 动态”特性。

3.2 隐藏内部实现
对函数的传统认知就是先声明-一个函数,然后再向里面添加代码。但反过来想也可以带来
一些启示:从所写的代码中挑选出一-个任意的片段，然后用函数声明对它进行包装，实际
.上就是把这些代码“隐藏”起来了。
实际的结果就是在这个代码片段的周围创建了一一个作用域气泡，也就是说这段代码中的任
何声明(变量或函数)都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的
作用域中。换句话说，可以把变量和函数包裹在--个函数的作用域中，然后用这个作用域
来“隐藏”它们。
如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。
但这样会破坏前面提到的最小特权原则，因为可能会暴漏过多的变量或函数，而这些变量
或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。
例如:
function doSomething(a) {
	b = a + doSomethingElse( a * 2 );
	console.log( b * 3 );
}
function doSomethingElse(a) {
	return a - 1;
}
var b;
doSomething( 2 ); // 15
在这个代码片段中，变量b和函数doSonethingElse(..)应该是doSomething(..)内部具体
实现的“私有” 内容。给予外部作用域对b和doSomethingElse(..)的“访问权限”不仅
没有必要，而且可能是“ 危险”的，因为它们可能被有意或无意地以非预期的方式使用,
从而导致超出了doSomething(..) 的适用条件。更“合理”的设计会将这些私有的具体内
容隐藏在doSomething(..)内部，例如:
function doSomething(a) {
	function doSome thingElse(a) {
		return a - 1;
	}
	var b;
	b = a+ doSomethingElse( a * 2 );
	console.log( b * 3 );
}
doSomething( 2 ); // 15
现在，b和doSomethingElse( ..)都无法从外部被访问，而只能被doSonething( ..)所控制。
功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会
依此进行实现。

规避冲突

“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，
两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致
变量的值被意外覆盖。
例如:
function foo() {
	function bar(a) {
		i=3;//修改for循环所属作用域中的i
		console.log( a + i );
	}
	for (var i=0; i<10; i++) {
	bar(i*2);//糟糕，无限循环了!
}
foo( );
bar(..)内部的赋值表达式i = 3意外地覆盖了声明在foo(..)内部for循环中的i。在这
个例子中将会导致无限循环，因为i被固定设置为3,永远满足小于10这个条件。
bar(..)内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以，var i = 3;
就可以满足这个需求(同时会为i声明一个前面提到过的“ 遮蔽变量")。另外- -种方法是
采用一个完全不同的标识符名称，比如var j = 3;。 但是软件设计在某种情况下可能自然
而然地要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是
唯一的最佳选择。
1.全局命名空间
变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它
们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。
这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是-一个对象。这个对象
被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属
性，而不是将自己的标识符暴漏在顶级的词法作用域中。
2.模块管理
另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选-一个来
使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器
的机制将库的标识符显式地导人到另外- -个特定的作用域中。
显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用
域的规则强制所有标识符都不能注人到共享作用域中，而是保持在私有、无冲突的作用域
中，这样可以有效规避掉所有的意外冲突。

3.3 函数作用域
我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐
藏”起来，外部作用域无法访问包装函数内部的任何内容。
例如:
var a=2;
function foo() { // <--添加这-行
	var a=3;
	console.log( a ); // 3
} // <--以及这一行
foo(); // <--以及这一行
console.log( a ); // 2
虽然这种技术可以解决--些问题，但是它并不理想，因为会导致一些额外的问题。首先,.
必须声明-一个具名函数foo()，意味着foo这个名称本身“污染”了所在作用域(在这个
例子中是全局作用域)。其次，必须显式地通过函数名( foo())调用这个函数才能运行其
中的代码。
如果函数不需要函数名(或者至少函数名可以不污染所在作用域)，并且能够自动运行，
这将会更加理想。
幸好，JavaScript 提供了能够同时解决这两个问题的方案、
var a=2;
(function foo(){ // <-- 添加这- -行
	var a=3;
	console.log( a ); // 3
})(); // <-- 以及这一行
console.log( a ); // 2
接下来我们分别介绍这里发生的事情。
首先，包装函数的声明以(function...而不仅是以function...开始。尽管看上去这并不
是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一-
个标准的函数声明来处理。

区分函数声明和表达式最简单的方法是看function关键字出现在声明中的位
置(不仅仅是一行代码，而是整个声明中的位置)。如果function是声明中
的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

3.3.1 匿名和具名
对于函数表达式你最熟悉的场景可能就是回调参数了，比如:
setTineout( function() {
	console.log("I waited 1 second!");
}, 1000 );
这叫作匿名函数表达式，因为function()..没有名称标识符。函数表达式可以是匿名的，
而函数声明则不可以省略函数名一在 JavaScript的语法中这是非法的。
匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是
它也有几个缺点需要考虑。
1.匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
2.如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments. callee引用，
比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑
自身。
3.匿名函数省略了对于代码可读性1可理解性很重要的函数名。一个描述性的名称可以让
代码不言自明。
行内函数表达式非常强大且有用一-匿 名和具名之间的区别并不会对这点有任何影响。给函
数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践:
setTineout( function timeoutHandler() { // 
	console.log( "I waited 1 second!" );
}, 1000 );

3.3.2 立即执行函数表达式
vara=2;
(function foo() {
	var a=3;
	console.log( a ); // 3
})();
console.log( a ); // 2
由于函数被包含在- -对( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个
( )可以立即执行这个函数，比如(function fo(){ .. })()。 第一个( )将函数变成表
达式，第二个( ) 执行了这个函数。
这种模式很常见，几年前社区给它规定了一个术语: IIFE， 代表立即执行函数表达式
(Immediately Invoked Function Expression) ; .
函数名对IFE当然不是必须的，IIPE 最常见的用法是使用一个匿名函数表达式。虽然使
用具名函数的IIFE并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一一个值
得推广的实践。
vara = 2;
(function IIFE() {
	var a=3;
	console.log( a ); // 3
})();
console.log( a ); // 2
相较于传统的IFE形式，很多人都更喜欢另一个改进的形式: (function(){ .. }())。 仔
细观察其中的区别。第一种形式中函数表达式被包含在( )中，然后在后面用另一个()括
号来调用。第二种形式中用来调用的()括号被移进了用来包装的( )括号中。
这两种形式在功能上是一致的。

第四章  提升
4.1 先有鸡还是先有蛋
直觉上会认为JavaScript代码在执行时是由上到下一行-行执行的。但实际上这并不完全
正确，有一种特殊情况会导致这个假设是错误的。
a=2;
var a;
console.log( a );
很多开发者会认为是undefined，因为var a声明在a = 2之后，他们自然而然地认为变量
被重新赋值了，因此会被赋予默认值undefined。但是，真正的输出结果是2。

4.2 编译器
引擎会在解释JavaScript代码之前首先对其进行编译。编译阶段中的一部分工作就是找到
所有的声明，并用合适的作用域将它们关联起来。
包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。
当你看到var a = 2; 时，可能会认为这是一个声明。但JavaScript实际上会将其看成两个
声明: var a; 和a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在
原地等待执行阶段。
我们的第-一个代码片段会以如下形式进行处理:
var a;
a=2;
console.log( a );
其中第一部分是编译，而第二部分是执行。
类似地，我们的第二个代码片段实际是按照以下流程处理的: 
var a;
console.log( a );
a=2;
因此，打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动
到了最上面。这个过程就叫作提升。
换句话说，先有声明后有赋值。
只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。
foo();
function foo() {
	console.log( a ); // undefined
	var a=2;
}
foo函数的声明(这个例子还包括实际函数的隐含值)被提升了，因此第一-行中的调用可
以正常执行。
另外值得注意的是，每个作用域都会进行提升操作。尽管前面大部分的代码片段已经简化
了(因为它们只包含全局作用域)，而我们正在讨论的foo(..)函数自身也会在内部对var
a进行提升(显然并不是提升到了整个程序的最上方)。因此这段代码实际上会被理解为下
面的形式:
function foo() {
	var a;
	console.log( a ); // undefined
	a =2;
}
foo();
可以看到，函数声明会被提升，但是函数表达式却不会被提升。
foo(); //不是ReferenceError,而是TypeError !
var foo = function bar() {
// ...
};
这段程序中的变量标识符foo()被提升并分配给所在作用域(在这里是全局作用域)，因此
foo()不会导致ReferenceError。但是foo此时并没有赋值(如果它是--个函数声明而不
是函数表达式，那么就会赋值)。foo() 由于对undefined值进行函数调用而导致非法操作，
因此抛出TypeError异常。
同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中
使用:
foo(); // TypeError
bar(); // ReferenceError
var foo = function bar() {
// ...
};
这个代码片段经过提升后，实际上会被理解为以下形式:
var foo;
foo(); // TypeError
bar(); // ReferenceError
foo = function() {
var bar = ...self.. .
}
4.3 函数优先
函数声明和变量声明都会被提升。但是-一个值得注意的细节(这个细节可以出现在有多个
“重复”声明的代码中)是函数会首先被提升，然后才是变量。
考虑以下代码:
foo(); // 1
var foo;
function foo() {
	console.log( 1 );
}
foo = function() {
	console.log( 2 );
};
会输出1而不是2!这个代码片段会被引擎理解为如下形式: .
function foo() {
	console.log( 1 );
}
foo(); // 1
foo = function() {
	console.log( 2 );
};
注意，var foo 尽管出现在function foo()... 的声明之前，但它是重复的声明(因此被忽
略了)，因为函数声明会被提升到普通变量之前。
尽管重复的var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。
foo(); // 3
function foo() {
	console.log( 1 );
var foo = function() {
	console.log( 2 );
};
function foo() {
	console.log( 3 );
}
一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代
码暗示的那样可以被条件判断所控制:
foo(); // "b"
var a = true;
if (a) {
	function foo() { console.log("a"); }
else {
	function foo() { console.log("b"); }
}

4.4 小结
我们习惯将var a = 2;看作一个声明，而实际上JavaScript引擎并不这么认为。它将var a
和a = 2当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。
这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。
可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的
最顶端，这个过程被称为提升。
声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。
要注意避免重复声明，特别是当普通的var声明和函数声明混合在-一起的时候，否则会引
起很多危险的问题!

第5章 作用域和闭包

5.2 实质问题
下面这段代码，清晰地展示了闭包:
function foo() {
	var a=2;
	function bar() {
		console.log( a );
	}
	return bar;
}
var baz = foo();
baz(); // 2一-朋友, 这就是闭包的效果。
函数bar()的词法作用域能够访问foo()的内部作用域。然后我们将bar()函数本身当作
一个值类型进行传递。在这个例子中，我们将bar所引用的函数对象本身当作返回值。
在foo()执行后，其返回值(也就是内部的bar()函数)赋值给变量baz并调用baz()，实
际上只是通过不同的标识符引用调用了内部的函数bar()。
bar()显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方
执行。
在foo()执行后，通常会期待foo()的整个内部作用域都被销毁，因为我们知道引擎有垃
圾回收器用来释放不再使用的内存空间。由于看上去foo()的内容不会再被使用，所以很
自然地会考虑对其进行回收。
而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此
没有被回收。谁在使用这个内部作用域?原来是bar()本身在使用。
拜bar()所声明的位置所赐，它拥有涵盖fo()内部作用域的闭包，使得该作用域能够一
直存活，以供bar()在之后任何时间进行引用。
bar()依然持有对该作用域的引用，而这个引用就叫作闭包。

因此，在几微秒之后变量baz被实际调用（调用内部函数bar），不出意料它可以访问定义
时的词法作用域，因此它也可以如预期般访问变量a。
这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的
词法作用域。
当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到
闭包。
function foo(){
	var a=2;
	function baz() {
		console.log( a ); // 2
	}
	bar( baz );
}
function bar(fn) {
fn(); //这就是闭包!
把内部函数baz传递给bar,当调用这个内部函数时(现在叫作fn)，它涵盖的foo()内部
作用域的闭包就可以观察到了，因为它能够访问a。
传递函数当然也可以是间接的。
var fn;
function foo() {
	var a=2;
	function baz() {
		console.log( a );
	}
	fn=baz;//将baz分配给全局变量
}
function bar() {
	fn(); // 这就是闭包!
}
foo();
bar(); // 2
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用
域的引用，无论在何处执行这个函数都会使用闭包。
function wait(message) {
	setTineout( function tiner() {
		console.log( message );
	}, 1000 );
}
wait( "Hello, closure!" );
将一个内部函数(名为timer)传递给setTineout(..)。timer 具有涵盖wait(..)作用域
的闭包，因此还保有对变量message的引用。
wait(..)执行1000毫秒后，它的内部作用域并不会消失，timer 函数依然保有wait(..)
作用域的闭包。
深入到引擎的内部原理中，内置的工具函数setTimeout(..)持有对一个参数的引用，这个
参数也许叫作fn 或者func，或者其他类似的名字。引擎会调用这个函数，在例子中就是
内部的timer函数，而词法作用域在这个过程中保持完整。
这就是闭包。

5.4 循环和闭包
要说明闭包，for循环是最常见的例子。
for (var i=1; i<=5; i++) {
	setTimeout( function timer() {
		console.log( i );
	}, *1000 );
}
正常情况下，我们对这段代码行为的预期是分别输出数字1~5,每秒一次，每次一个。
但实际上，这段代码在运行时会以每秒一次的频率输出五次6。
这是为什么?
首先解释6是从哪里来的。这个循环的终止条件是i不再<=5。条件首次成立时i的值是
6。因此，输出显示的是循环结束时i的最终值。
仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上,
当定时器运行时即使每个迭代中执行的是setTineout(... 0)， 所有的回调函数依然是在循
环结束后才会被执行，因此会每次输出一个6出来。
这里引伸出一个更深入的问题，代码中到底有什么缺陷导致它的行为同语义所暗示的不--
致呢?
缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。但是
根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，
但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。
这样说的话，当然所有函数共享-一个i的引用。循环结构让我们误以为背后还有更复杂的
机制在起作用，但实际上没有。如果将延迟函数的回调重复定义五次，完全不使用循环，
那它同这段代码是完全等价的。
下面回到正题。缺陷是什么?我们需要更多的闭包作用域，特别是在循环的过程中每个迭
代都需要-一个闭包作用域。
可以对这段代码进行一些改进:
for (var i=1; i<=5; i++) {
	(function(j) {
		se tTimeout( function timer() {
			console.log( j );
		}，j*1000 );
	})( i );
}
当然，这些IIFE也不过就是函数，因此我们可以将i传递进去，如果愿意的话可以将变量
名定为j，当然也可以还叫作i。无论如何这段代码现在可以工作了。
在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的
作用域封闭在每个迭代内部，每个迭代中都会含有-个具有正确值的变量供我们访问。






